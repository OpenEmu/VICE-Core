<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../../doc/vice.texi on 19 December 2018 -->

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>VICE Manual - 9  Snapshots</TITLE>
<style type="text/css">
    @import 'vice.css';
</style>
</HEAD>
<BODY>
Go to the <A HREF="vice_1.html">first</A>, <A HREF="vice_8.html">previous</A>, <A HREF="vice_10.html">next</A>, <A HREF="vice_22.html">last</A> section, <A HREF="vice_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC227" HREF="vice_toc.html#TOC227">9  Snapshots</A></H1>

<P>
Every VICE emulator has a built-in snapshot feature, that saves the
complete emulator state into one file for later use.
You can therefore save the emulator state - including the state of
the game you are playing for example - in a single file.

</P>



<H2><A NAME="SEC228" HREF="vice_toc.html#TOC228">9.1  Snapshot usage</A></H2>

<P>
A snapshot is one file containining the complete emulator state.  A
snapshot file can be generated by selecting the "Save snapshot"
command at any time.  This will pop up a requester from which you can
specify whether the snapshot should also contain the disk and ROM
status.

</P>
<P>
A snapshot file can be used to restore the emulator state by selecting
the <CODE>load snapshot</CODE> menu entry at any time.
Unfortunately attached ROM images/cartridges are only supported in the VIC20,
the PET and the CBM-II emulators at this time.

</P>
<P>
The memory configuration of the emulator is saved in the snapshot file as
well. This configuration is restored when the snapshot is loaded.

</P>
<P>
A quick snapshot can now be made by pressing the <CODE>M-F11</CODE> key and
reloaded by pressing the <CODE>M-F10</CODE> key.

</P>


<H2><A NAME="SEC229" HREF="vice_toc.html#TOC229">9.2  Snapshot format</A></H2>

<P>
A snapshot file consists of several modules of mostly different types.
Each module has a name and saves the state of an entity like a CIA, the CPU,
or the memory.

</P>



<H3><A NAME="SEC230" HREF="vice_toc.html#TOC230">9.2.1  Emulator modules</A></H3>

<P>
This section lists the modules that are contained in each of the
emulators snapshot files.

</P>



<H4><A NAME="SEC231" HREF="vice_toc.html#TOC231">9.2.1.1  x64 modules</A></H4>

<P>
The modules in the x64 emulator are:

</P>
<TABLE BORDER>

<TR><TD>Name</TD>

<TD>Type</TD>
<TD>Description</TD>
</TR>
<TR><TD>MAINCPU</TD>

<TD>6502</TD>
<TD>The Main CPU - although it is a 6510, only the 6502 core is saved here</TD>
</TR>
<TR><TD>C64MEM</TD>

<TD>Memory</TD>
<TD>Holds the RAM contents of the C64.  Also the CPU I/O register contents are saved here.</TD>
</TR>
<TR><TD>C64ROM</TD>

<TD>ROM images</TD>
<TD>Dump of the system ROMs</TD>
</TR>
<TR><TD>VIC-II</TD>

<TD>656*</TD>
<TD>The VIC-II of the C64/128</TD>
</TR>
<TR><TD>CIA1</TD>

<TD>6526</TD>
<TD>The CIA for the interrupts and the keyboard</TD>
</TR>
<TR><TD>CIA2</TD>

<TD>6526</TD>
<TD>The CIA for the userport, IEC-bus and RS232.</TD>
</TR>
<TR><TD>SID</TD>

<TD>6581</TD>
<TD>The SID sound chip of the C64/C128</TD>
</TR>
<TR><TD>REU*</TD>

<TD></TD>
<TD>The RAM Extension Unit state (optional)</TD>
</TR>
<TR><TD>ACIA1</TD>

<TD>6551</TD>
<TD>An ACIA (RS232 interface) at $DE00 (optional)</TD>
</TR>
<TR><TD>TPI</TD>

<TD>6525</TD>
<TD>A TPI at $DF00 for a parallel IEEE488 interface (optional)</TD>
</TR>
<TR><TD>*</TD>

<TD>Drive modules</TD>
<TD>The emulated drive(s) have their own modules see section <A HREF="vice_9.html#SEC236">9.2.1.6  Drive modules</A></TD>
</TR></TABLE>

<P>
Some of the modules are optional and are only saved if the specific
feature is enabled at save-time.  If the module is found when restoring
the state the optional features are enabled, and disabled otherwise.

</P>


<H4><A NAME="SEC232" HREF="vice_toc.html#TOC232">9.2.1.2  x128 modules</A></H4>

<P>
The modules in the x128 emulator are:

</P>
<TABLE BORDER>

<TR><TD>Name</TD>

<TD>Type</TD>
<TD>Description</TD>
</TR>
<TR><TD>MAINCPU</TD>

<TD>6502</TD>
<TD>The Main CPU - although it is a 6510, only the 6502 core is saved here</TD>
</TR>
<TR><TD>C128MEM</TD>

<TD>Memory</TD>
<TD>Holds the RAM contents of the C64.  Also the CPU I/O register contents are saved here.</TD>
</TR>
<TR><TD>C128ROM</TD>

<TD>ROM images</TD>
<TD>Dump of the system ROMs</TD>
</TR>
<TR><TD>VIC-II</TD>

<TD>656*</TD>
<TD>The VIC-II of the C64/128</TD>
</TR>
<TR><TD>CIA1</TD>

<TD>6526</TD>
<TD>The CIA for the interrupts and the keyboard</TD>
</TR>
<TR><TD>CIA2</TD>

<TD>6526</TD>
<TD>The CIA for the userport, IEC-bus and RS232.</TD>
</TR>
<TR><TD>SID</TD>

<TD>6581</TD>
<TD>The SID sound chip of the C64/C128</TD>
</TR>
<TR><TD>ACIA1</TD>

<TD>6551</TD>
<TD>An ACIA at $DE00 (optional)</TD>
</TR>
<TR><TD>TPI</TD>

<TD>6525</TD>
<TD>A TPI at $DF00 for a parallel IEEE488 interface (optional)</TD>
</TR>
<TR><TD>*</TD>

<TD>Drive modules</TD>
<TD>The emulated drive(s) have their own modules see section <A HREF="vice_9.html#SEC236">9.2.1.6  Drive modules</A></TD>
</TR></TABLE>

<P>
Some of the modules are optional and are only saved if the specific
feature is enabled at save-time.  If the module is found when restoring
the state the optional features are enabled, and disabled otherwise.

</P>
<P>
Not yet supported are the 80 column video chip, cartridges and
RAM expansion unit.

</P>


<H4><A NAME="SEC233" HREF="vice_toc.html#TOC233">9.2.1.3  xvic modules</A></H4>

<P>
The modules in the xvic emulator are:

</P>
<TABLE BORDER>

<TR><TD>Name</TD>

<TD>Type</TD>
<TD>Description</TD>
</TR>
<TR><TD>MAINCPU</TD>

<TD>6502</TD>
<TD>The Main CPU</TD>
</TR>
<TR><TD>VIC20MEM</TD>

<TD>Memory</TD>
<TD>Holds the RAM contents of the VIC20.</TD>
</TR>
<TR><TD>VIC20ROM</TD>

<TD>ROM images</TD>
<TD>Holds the ROM images of the VIC20, including possibly attached cartridges</TD>
</TR>
<TR><TD>VIC-I</TD>

<TD>656*</TD>
<TD>The VIC-I of the VIC20</TD>
</TR>
<TR><TD>VIA1</TD>

<TD>6522</TD>
<TD>The VIA for the interrupts and the keyboard</TD>
</TR>
<TR><TD>VIA2</TD>

<TD>6522</TD>
<TD>The VIA for the userport, IEC-bus and RS232.</TD>
</TR>
<TR><TD>*</TD>

<TD>Drive modules</TD>
<TD>The emulated drive(s) have their own modules see section <A HREF="vice_9.html#SEC236">9.2.1.6  Drive modules</A></TD>
</TR></TABLE>



<H4><A NAME="SEC234" HREF="vice_toc.html#TOC234">9.2.1.4  xpet modules</A></H4>

<P>
The modules in the xpet emulator are:

</P>
<TABLE BORDER>

<TR><TD>Name</TD>

<TD>Type</TD>
<TD>Description</TD>
</TR>
<TR><TD>MAINCPU</TD>

<TD>6502</TD>
<TD>The Main CPU</TD>
</TR>
<TR><TD>PETMEM</TD>

<TD>Memory</TD>
<TD>Holds the RAM contents of the PET.</TD>
</TR>
<TR><TD>PETROM</TD>

<TD>ROM images</TD>
<TD>Holds the ROM images of the PET, including possibly attached cartridges</TD>
</TR>
<TR><TD>CRTC</TD>

<TD>6545</TD>
<TD>The CRTC of the PET. This is also included if it is a dump of a PET without CRTC, because the video state is saved here anyway.</TD>
</TR>
<TR><TD>PIA1</TD>

<TD>6520</TD>
<TD>The PIA for the interrupts, tape and the keyboard</TD>
</TR>
<TR><TD>PIA2</TD>

<TD>6520</TD>
<TD>The PIA for the IEEE488-bus</TD>
</TR>
<TR><TD>VIA</TD>

<TD>6522</TD>
<TD>The VIA for IEEE488, userport, sound</TD>
</TR>
<TR><TD>ACIA1</TD>

<TD>6551</TD>
<TD>The ACIA for the SuperPET.  This module is optional.</TD>
</TR>
<TR><TD>DWWPIA</TD>

<TD>6520</TD>
<TD>The PIA for the DWW hires board.</TD>
</TR>
<TR><TD>CPU6809</TD>

<TD>6809</TD>
<TD>The extra CPU in the SuperPET.  This module is optional.</TD>
</TR>
<TR><TD>*</TD>

<TD>Drive modules</TD>
<TD>The emulated drive(s) have their own modules see section <A HREF="vice_9.html#SEC236">9.2.1.6  Drive modules</A></TD>
</TR></TABLE>



<H4><A NAME="SEC235" HREF="vice_toc.html#TOC235">9.2.1.5  xcbm2 and xcbm5x0 modules</A></H4>

<P>
The modules in the xcbm2 and xcbm5x0 emulators are:

</P>
<TABLE BORDER>

<TR><TD>Name</TD>

<TD>Type</TD>
<TD>Description</TD>
</TR>
<TR><TD>MAINCPU</TD>

<TD>6502</TD>
<TD>The Main CPU - although it is a 6509, only the 6502 core is saved here</TD>
</TR>
<TR><TD>CBM2MEM</TD>

<TD>Memory</TD>
<TD>Holds the RAM contents of the CBM-II models.  Also holds the exec-bank and indirection bank registers</TD>
</TR>
<TR><TD>C500DATA</TD>

<TD></TD>
<TD>Holds additional state information necessary for the C500 (e.g. cycles till the next IRQ)</TD>
</TR>
<TR><TD>CBM2ROM</TD>

<TD>Memory</TD>
<TD>optional.  Holds the ROM images.</TD>
</TR>
<TR><TD>CRTC</TD>

<TD>6545</TD>
<TD>The video chip for the C6*0 and C7*0 models (only those models).</TD>
</TR>
<TR><TD>VIC-II</TD>

<TD>656?</TD>
<TD>The video chip for the C5*0 models (only the C5*0 models).</TD>
</TR>
<TR><TD>CIA1</TD>

<TD>6526</TD>
<TD>The CIA for IEEE 488 and userport.</TD>
</TR>
<TR><TD>TPI1</TD>

<TD>6525</TD>
<TD>TPI 1 for IEEE488</TD>
</TR>
<TR><TD>TPI2</TD>

<TD>6525</TD>
<TD>TPI 2 for interrupts and keyboard.</TD>
</TR>
<TR><TD>ACIA1</TD>

<TD>6551</TD>
<TD>The RS232 interface</TD>
</TR>
<TR><TD>SID</TD>

<TD>6581</TD>
<TD>The CBM2s SID sound chip</TD>
</TR>
<TR><TD>*</TD>

<TD>Drive modules</TD>
<TD>The emulated drive(s) have their own modules see section <A HREF="vice_9.html#SEC236">9.2.1.6  Drive modules</A></TD>
</TR></TABLE>



<H4><A NAME="SEC236" HREF="vice_toc.html#TOC236">9.2.1.6  Drive modules</A></H4>

<P>
The modules for the real disk drive emulation are included in the emulator
when the emulation is enabled during the writing of the snapshot.

</P>
<TABLE BORDER>

<TR><TD>Name</TD>

<TD>Type</TD>
<TD>Description</TD>
</TR>
<TR><TD>*CPU</TD>

<TD>6502</TD>
<TD>The Drive 0 CPU</TD>
</TR>
<TR><TD>*</TD>

<TD>*</TD>
<TD>*</TD>
</TR></TABLE>



<H3><A NAME="SEC237" HREF="vice_toc.html#TOC237">9.2.2  Module formats</A></H3>

<P>
This section shows the basic module framework and the contents of the
different types of modules.

</P>
<P>
The single chip modules contain the <B>chip</B> state, not the state of the
emulator.  We tried to make the format as implementation-independent as
possible, to allow reuse of snapshots in later versions of this
emulator, or even in other emulators.

</P>



<H4><A NAME="SEC238" HREF="vice_toc.html#TOC238">9.2.2.1  Terminology</A></H4>

<P>
In this section we use certain abbreviations to define the types of the
data saved in the snapshot.

</P>
<DL COMPACT>

<DT><CODE>BYTE</CODE>
<DD>
8 bit integer.
<DT><CODE>WORD</CODE>
<DD>
16 bit integer.  Saved with low-byte first, high-byte last.
<DT><CODE>DWORD</CODE>
<DD>
32 bit integer.  Saved with low-word first, then high-word.  Each word saved with its low-byte first.
<DT><CODE>ARRAY</CODE>
<DD>
Array of BYTE values.  Length depends on the description.
</DL>

<P>
The tables for the single modules state the type, name and description
of the data saved in the modules.  The data is saved in the order it is
in the tables, so no offset is given.

</P>


<H4><A NAME="SEC239" HREF="vice_toc.html#TOC239">9.2.2.2  Module framework</A></H4>

<P>
The VICE snapshot file starts with the magic string and includes the
fileformat version number.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>19 BYTE</TD>

<TD>MAGIC</TD>
<TD>"VICE Snapshot File\032", padded with 0</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>VMAJOR</TD>
<TD>fileformat major version number</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>VMINOR</TD>
<TD>fileformat minor version number</TD>
</TR>
<TR><TD>16 BYTE</TD>

<TD>MACHINENAME</TD>
<TD>Name of emulated machine, like "PET", "CBM-II", "VIC20", "C64" or "C128". zerobyte-padded.</TD>
</TR></TABLE>

<P>
The file header is followed by a number of different snapshot modules.

</P>
<P>
Each module has a header with the information given in the table below.
The header includes two version numbers, VMAJOR and VMINOR.  Modules
with the same VMAJOR should be able to be exchanged.  I.e. higher VMINOR
numbers only append to the data for lower VMINOR.  This additional data
is ignored by older restore routines.  The other way around newer
restore routines must accept the fewer info from lower VMINOR dumps.
Changes in VMAJOR might introduce any incompatibility you like, but
that's what VMAJOR is for after all :-)

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>16 BYTE</TD>

<TD>MODULENAME</TD>
<TD>The name of the module in ASCII, padded with 0 to 16 byte.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>VMAJOR</TD>
<TD>major version number</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>VMINOR</TD>
<TD>minor version number</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>SIZE</TD>
<TD>size of the module, including this header</TD>
</TR></TABLE>



<H4><A NAME="SEC240" HREF="vice_toc.html#TOC240">9.2.2.3  CPU 6502 module</A></H4>

<P>
This module saves the core 6502 state.  You will find a clock value
there.  All other modules save their own clock values relative to this
value.  However, the drive modules save their clocks relative to their
appropriate CPUs of course.

</P>
<P>
<B>Warning:</B> This module is still under construction and saves some
information that is not sure to be VICE-independent.  If in doubt, read
the source.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>CLK</TD>
<TD>the current CPU clock value.  All other clock values are relative to this.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>AC</TD>
<TD>Accumulator</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>XR</TD>
<TD>X index register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>YR</TD>
<TD>Y index register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SP</TD>
<TD>Stack Pointer</TD>
</TR>
<TR><TD>WORD</TD>

<TD>PC</TD>
<TD>Programm Counter</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ST</TD>
<TD>Status Registers</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>LASTOPCODE</TD>
<TD>?</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>IRQCLK</TD>
<TD>absolute CLK when the IRQ line came active</TD>
</TR>
<TR><TD>DOWRD</TD>

<TD>NMICLK</TD>
<TD>absolute CLK when the NMI line came active</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>?</TD>
<TD>?</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>?</TD>
<TD>?</TD>
</TR></TABLE>



<H4><A NAME="SEC241" HREF="vice_toc.html#TOC241">9.2.2.4  CPU 6809 module</A></H4>

<P>
This module saves the core 6809 state.  You will find a clock value
there.  All other modules save their own clock values relative to this
value.  However, the drive modules save their clocks relative to their
appropriate CPUs of course.

</P>
<P>
<B>Warning:</B> This module is still under construction and saves some
information that is not sure to be VICE-independent.  If in doubt, read
the source.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>CLK</TD>
<TD>the current CPU clock value.  All other clock values are relative to this.</TD>
</TR>
<TR><TD>WORD</TD>

<TD>X</TD>
<TD>The X register</TD>
</TR>
<TR><TD>WORD</TD>

<TD>Y</TD>
<TD>The Y register</TD>
</TR>
<TR><TD>WORD</TD>

<TD>U</TD>
<TD>The U register</TD>
</TR>
<TR><TD>WORD</TD>

<TD>PC</TD>
<TD>The Program Counter register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DP</TD>
<TD>The Direct Page register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CC</TD>
<TD>The Condition Code register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>A</TD>
<TD>The A register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>B</TD>
<TD>The B register</TD>
</TR>
<TR><TD></TD>

<TD></TD>
<TD>The following are for 6309 compatibility:</TD>
</TR>
<TR><TD>WORD</TD>

<TD>V</TD>
<TD>The V register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>E</TD>
<TD>The E register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>F</TD>
<TD>The F register</TD>
</TR></TABLE>



<H4><A NAME="SEC242" HREF="vice_toc.html#TOC242">9.2.2.5  CIA module</A></H4>

<P>
The CIA 6526 is an I/O port chip with 2 8-bit I/O ports, a shift register,
two timers, a Time of Day clock and interrupts.

</P>
<P>
Version numbers: Major 1, Minor 1.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORA</TD>
<TD>Output register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORB</TD>
<TD>Output register B</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRA</TD>
<TD>Data direction register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRB</TD>
<TD>Data direction register B</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TAC</TD>
<TD>Timer A counter value</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TBC</TD>
<TD>Timer B counter value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TOD_TEN</TD>
<TD>Time of Day - current tenth of second</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TOD_SEC</TD>
<TD>Time of Day - current seconds</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TOD_MIN</TD>
<TD>Time of Day - current minutes</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TOD_HR</TD>
<TD>Time of Day - current hours</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SDR</TD>
<TD>contents of shift register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IER</TD>
<TD>mask of enabled interrupt masks</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CRA</TD>
<TD>Control register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CRB</TD>
<TD>Control register B</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TAL</TD>
<TD>Timer A latch value</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TBL</TD>
<TD>Timer B latch value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IFR</TD>
<TD>mask of currently active interrupts</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PBSTATE</TD>
<TD>Bit 6/7 reflect the PB6/7 toggle bit state.  Bit 2/3 reflect the corresponding port bit state.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SRHBITS</TD>
<TD>number of half-bits to still shift in/out SDR</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ALARM_TEN</TD>
<TD>Time of Day - alarm tenth of second</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ALARM_SEC</TD>
<TD>Time of Day - alarm seconds</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ALARM_MIN</TD>
<TD>Time of Day - alarm minutes</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ALARM_HR</TD>
<TD>Time of Day - alarm hours</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>READICR</TD>
<TD>current clock minus the clock when ICR was read last plus 128.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODLATCHED</TD>
<TD>Bit 0: 1= latched for reading, Bit 1: 2=stopped for writing</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODL_TEN</TD>
<TD>Time of Day - latched tenth of second</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODL_SEC</TD>
<TD>Time of Day - latched seconds</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODL_MIN</TD>
<TD>Time of Day - latched minutes</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODL_HR</TD>
<TD>Time of Day - latched hours</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>TOD_TICKS</TD>
<TD>clk ticks till next tenth of second</TD>
</TR>
<TR><TD>--</TD>

<TD>--</TD>
<TD>The next items have been added in V1.1</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TASTATE</TD>
<TD>The state bits of the CIA timer A, according to ciatimer.h</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TBSTATE</TD>
<TD>The state bits of the CIA timer B, according to ciatimer.h</TD>
</TR></TABLE>

<P>
The last two items have been added in CIA snapshot version 1.1 due
to the improved CIA emulation in the newer VICE versions.
Some state bits correspond to the CIA state as described in the
"A Software Model of the CIA 6526" document by Wolfgang Lorenz,
some are delayed versions. For more read the source file
<CODE>ciatimer.h</CODE>.

</P>


<H4><A NAME="SEC243" HREF="vice_toc.html#TOC243">9.2.2.6  VIA module</A></H4>

<P>
The VIA 6522 is the predecessor of the CIA and also an I/O port chip
with 2 8-bit I/O ports, a shift register,
two timers and interrupts.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORA</TD>
<TD>Output register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRA</TD>
<TD>Data direction register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORB</TD>
<TD>Output register B</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRB</TD>
<TD>Data direction register B</TD>
</TR>
<TR><TD>WORD</TD>

<TD>T1L</TD>
<TD>Timer 1 Latch value</TD>
</TR>
<TR><TD>WORD</TD>

<TD>T1C</TD>
<TD>Timer 1 counter value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>T2L</TD>
<TD>Timer 2 latch (8 bit as only lower byte is used)</TD>
</TR>
<TR><TD>WORD</TD>

<TD>T2C</TD>
<TD>Timer 2 counter value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>RUNFL</TD>
<TD>bit 7: timer 1 will generate IRQ on underflow; bit 6: timer 2 will generate IRQ on underflow</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SR</TD>
<TD>Shift register value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ACR</TD>
<TD>Auxiliary control register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PCR</TD>
<TD>Peripheral control register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IFR</TD>
<TD>active interrupts</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IER</TD>
<TD>interrupt mask</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PB7</TD>
<TD>bit 7 = pb7 state</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SRHBITS</TD>
<TD>number of half-bits to shift out on SR</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CABSTATE</TD>
<TD>bit 7: state of CA2 pin, bit 6: state of CB2 pin</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ILA</TD>
<TD>Port A Input Latch (see ACR bit 0)</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ILB</TD>
<TD>Port B Input Latch (see ACR bit 1)</TD>
</TR></TABLE>



<H4><A NAME="SEC244" HREF="vice_toc.html#TOC244">9.2.2.7  PIA module</A></H4>

<P>
The PIA 6520 is a chip with two I/O ports (Parallel Interface Adapter)
and four additional handshake lines.  The chip is pretty the same for
Port A and B, only that Port A implements handshake on read operation
and port B on write operation.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>ORA</TD>
<TD>Output register A</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>DDRA</TD>
<TD>Data Direction Register A</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CTRLA</TD>
<TD>Control Register A</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>ORB</TD>
<TD>Output register B</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>DDRB</TD>
<TD>Data Direction Register B</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CTRLB</TD>
<TD>Control Register B</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CABSTATE</TD>
<TD>Bit 7 = state of CA2, Bit 6 = state of CB2</TD>
</TR></TABLE>



<H4><A NAME="SEC245" HREF="vice_toc.html#TOC245">9.2.2.8  TPI module</A></H4>

<P>
The TPI 6525 is a chip with three I/O ports (Tri-Port-Interface).  One of
the ports can double as an interrupt prioritizer.  Therefore we also have
to save the states of the interrupt stack etc.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PRA</TD>
<TD>Port A output register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PRB</TD>
<TD>Port B output register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PRC</TD>
<TD>Port C output register (doubles as IRQ latch register)</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRA</TD>
<TD>Port A data direction register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRB</TD>
<TD>Port B data direction register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRC</TD>
<TD>Port C data direction register (doubles as IRQ mask register)</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CR</TD>
<TD>Control Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>AIR</TD>
<TD>Active interrupt register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>STACK</TD>
<TD>Interrupt stack - the interrupt bits that are not (yet) served.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CABSTATE</TD>
<TD>State of CA/CB pins.  Bit 7 = state of CA, Bit 6 = state of CB</TD>
</TR></TABLE>



<H4><A NAME="SEC246" HREF="vice_toc.html#TOC246">9.2.2.9  RIOT module</A></H4>

<P>
The RIOT 6532 is a chip with two I/O ports, some RAM and a Timer.
The chip contains 128 byte RAM, but the RAM is not saved in the
RIOT snapshot, but in the memory section.

</P>
<P>
<B>Warning:</B> This module is still under construction

</P>
<P>
Version numbers: Major 0, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORA</TD>
<TD>Port A output register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRA</TD>
<TD>Port A data direction register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORB</TD>
<TD>Port B output register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRB</TD>
<TD>Port B data direction register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>EDGECTRL</TD>
<TD>Bit 0/1: A0/A1 address bits written to edgecontrol registers</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IRQFL</TD>
<TD>Bit 6/7: A6/A7 IRQ flag register. Bit 0: state of the IRQ line (0=inactive, 1=active)</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>N</TD>
<TD>timer value</TD>
</TR>
<TR><TD>WORD</TD>

<TD>DIVIDER</TD>
<TD>Pre-scale divider value (1, 8, 64, or 1024)</TD>
</TR>
<TR><TD>WORD</TD>

<TD>REST</TD>
<TD>cycles since the last counter change</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IRQEN</TD>
<TD>Bit 0: 0= timer IRQ disabled, 1= timer IRQ enabled</TD>
</TR></TABLE>



<H4><A NAME="SEC247" HREF="vice_toc.html#TOC247">9.2.2.10  SID module</A></H4>

<P>
<B>Warning:</B> This module is still under construction.

</P>


<H4><A NAME="SEC248" HREF="vice_toc.html#TOC248">9.2.2.11  ACIA module</A></H4>

<P>
The ACIA 6551 is an RS232 interface chip.  VICE emulates RS232 connections
via <CODE>/dev/ttyS*</CODE> (Unix) or <CODE>COM:</CODE> (DOS/WIN - not yet?).
When saving a snapshot, those connections are of course lost.
The state of the ACIA however is restored if possible.  I.e. if a connection
is already open when restoring the snapshot, this connection is used
instead.  If no connection is open, a carrier/DTR drop is emulated.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TDR</TD>
<TD>Transmit Data Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>RDR</TD>
<TD>Receiver Data Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SR</TD>
<TD>Status Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CMD</TD>
<TD>Command Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CTRL</TD>
<TD>Ctrl Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>INTX</TD>
<TD>0 = no data to tx; 1 = Data is being transmitted; 2 = Data is being transmitted while data in TDR waiting to be put to internal transmit register</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>TICKS</TD>
<TD>Clock ticks till the next TDR empty interrupt</TD>
</TR></TABLE>



<H4><A NAME="SEC249" HREF="vice_toc.html#TOC249">9.2.2.12  VIC-I module</A></H4>

<P>
<B>Warning:</B> This module is still under construction.

</P>


<H4><A NAME="SEC250" HREF="vice_toc.html#TOC250">9.2.2.13  VIC-II module</A></H4>

<P>
<B>Warning:</B> This module is still under construction.

</P>


<H4><A NAME="SEC251" HREF="vice_toc.html#TOC251">9.2.2.14  CRTC module</A></H4>

<P>
<B>Warning:</B> After VICE version 1.0 the CRTC emulation has improved
considerably. Especially it is now cycle exact. Therefore a lot more
variables must be saved. The snapshot module version jumped from
0.0 to 1.0. Newer versions of VICE can read the old snapshots, but
older versions (1.0 and below) cannot read the new snapshots.

</P>
<P>
<B>Warning:</B> This module is still under construction.  Especially the
RASTERY and RASTERLINE values might be bogus.

</P>
<P>
Version numbers: Major 1, Minor 1.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD></TD>

<TD></TD>
<TD>Hardware options</TD>
</TR>
<TR><TD>WORD</TD>

<TD>VADDR_MASK</TD>
<TD>Mask of the address bits valid when accessing the video memory</TD>
</TR>
<TR><TD>WORD</TD>

<TD>VADDR_CHARSWITCH</TD>
<TD>If one bit in the video address is used to switch the character generator, it is masked here.</TD>
</TR>
<TR><TD>WORD</TD>

<TD>VADDR_CHAROFFSET</TD>
<TD>The offset in characters in the character generator that CHARSWITCH switches.</TD>
</TR>
<TR><TD>WORD</TD>

<TD>VADDR_REVSWITCH</TD>
<TD>If one bit in the video address inverts the screen, it is masked here.</TD>
</TR>
<TR><TD>WORD</TD>

<TD>CHARGEN_MASK</TD>
<TD>size of character generator in byte - 1</TD>
</TR>
<TR><TD>WORD</TD>

<TD>CHARGEN_OFFSET</TD>
<TD>offset given by external circuitry</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>HW_CURSOR</TD>
<TD>external hardware cursor circuitry enabled</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>HW_COLS</TD>
<TD>number of displayed columns during one character clock cycle</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>HW_BLANK</TD>
<TD>set if the hardware blank feature is available</TD>
</TR>
<TR><TD></TD>

<TD></TD>
<TD>CRTC register</TD>
</TR>
<TR><TD>20 BYTE</TD>

<TD>REGISTERS</TD>
<TD>register DUMP of the CRTC registers 0-19.</TD>
</TR>
<TR><TD></TD>

<TD></TD>
<TD>CRTC internal registers</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>REGNO</TD>
<TD>The current index in the CRTC register file</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CHAR</TD>
<TD>The current cycle within the current rasterline</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CHARLINE</TD>
<TD>The current character line</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>YCOUNTER</TD>
<TD>The current rasterline in the character</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CRSRCNT</TD>
<TD>Framecounter for the blinking cursor</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CRSRSTATE</TD>
<TD>if set the hardware cursor is visible</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CRSRLINES</TD>
<TD>set if ycounter is within the active cursor rasterlines for a char</TD>
</TR>
<TR><TD>WORD</TD>

<TD>CHARGEN_REL</TD>
<TD>relative base of currently used character generator in ROM (in byte)</TD>
</TR>
<TR><TD>WORD</TD>

<TD>SCREEN_REL</TD>
<TD>screen address to load the counter at the beginning of the next rasterline</TD>
</TR>
<TR><TD>WORD</TD>

<TD>VSYNC</TD>
<TD>number of rasterlines left within vsync; 0 = not in vsync</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>VENABLE</TD>
<TD>vertical enable flipflop; 1= display, 0= blank.</TD>
</TR>
<TR><TD></TD>

<TD></TD>
<TD>(VICE-dependent?) variables</TD>
</TR>
<TR><TD>WORD</TD>

<TD>SCREEN_WIDTH</TD>
<TD>width of the current display window</TD>
</TR>
<TR><TD>WORD</TD>

<TD>SCREEN_HEIGHT</TD>
<TD>height of the current display window</TD>
</TR>
<TR><TD>WORD</TD>

<TD>SCREEN_XOFFSET</TD>
<TD>x position where the first character in a line starts in the window...</TD>
</TR>
<TR><TD>WORD</TD>

<TD>HJITTER</TD>
<TD>...but only after adding this jitter</TD>
</TR>
<TR><TD>WORD</TD>

<TD>SCREEN_YOFFSET</TD>
<TD>x position where the first character in a line starts in the window...</TD>
</TR>
<TR><TD>WORD</TD>

<TD>FRAMELINES</TD>
<TD>expected number of rasterlines for the current frame</TD>
</TR>
<TR><TD>WORD</TD>

<TD>CURRENT_LINE</TD>
<TD>current rasterline as seen from the CRTC</TD>
</TR>
<TR><TD></TD>

<TD></TD>
<TD>This value has been added in module version V1.1</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>FLAG</TD>
<TD>Bit 0: If 1 then bit in VADDR_REVSWITCH must be set for reverse; if 0 then bit must be cleared for reverse.</TD>
</TR></TABLE>

<P>
Here is the reference for the previous CRTC snapshot module. It is outdated
and will not be read by this and later versions of VICE.

</P>
<P>
Version numbers: Major 0, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>RASTERY</TD>
<TD>The number of clock cycles from rasterlines start</TD>
</TR>
<TR><TD>WORD</TD>

<TD>RASTERLINE</TD>
<TD>The current rasterline</TD>
</TR>
<TR><TD>WORD</TD>

<TD>ADDRMASK</TD>
<TD>The address mask valid for the CRTC.  All memory accesses are masked with this value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>HWFLAG</TD>
<TD>Bit 0: 1= hardware cursor available.  Bit 1: 1= number of columns is doubled by external hardware</TD>
</TR>
<TR><TD>20 BYTE</TD>

<TD>REGISTERS</TD>
<TD>register DUMP of the CRTC registers 0-19.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CRSRSTATE</TD>
<TD>Hardware cursor: Bits 0-3: frame counter till next crsr line toggle. Bit 7: 1= cursor line active</TD>
</TR></TABLE>



<H4><A NAME="SEC252" HREF="vice_toc.html#TOC252">9.2.2.15  C64 memory module</A></H4>

<P>
The C64 memory module actually consists of two modules.  The "C64MEM" module
is mandatory and contains the RAM dump.  The "C64ROM" module is optional
and contains a dump of the ROM images.

</P>
<P>
The size of the C64 memory modules differs with each different memory
configuration. The RAM configuration is saved in the snapshot, and
restored when the snapshot is loaded. The attached cartridges are
<B>not yet(!)</B> saved and not yet restored upon load.

</P>
<P>
Version numbers: Major 0, Minor 0

</P>
<P>
<B>The C64MEM module</B>

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CPUDATA</TD>
<TD>CPU port data byte</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CPUDIR</TD>
<TD>CPU port direction byte</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>EXROM</TD>
<TD>state of the EXROM line (?)</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>GAME</TD>
<TD>state of the GAME line (?)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM</TD>
<TD>64k RAM dump</TD>
</TR></TABLE>

<P>
<B>The C64ROM module</B>

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>KERNAL</TD>
<TD>8k dump of the kernal ROM</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BASIC</TD>
<TD>8k dump of the basic ROM</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>CHARGEN</TD>
<TD>4k dump of the chargen ROM</TD>
</TR></TABLE>



<H4><A NAME="SEC253" HREF="vice_toc.html#TOC253">9.2.2.16  C128 memory module</A></H4>

<P>
The C128 memory module actually consists of two modules.  The "C128MEM" module
is mandatory and contains the RAM dump.  The "C128ROM" module is optional
and contains a dump of the ROM images.

</P>
<P>
The size of the C128 memory modules differs with each different memory
configuration. The RAM configuration is saved in the snapshot, and
restored when the snapshot is loaded. The attached cartridges are
also restored upon load if they have been saved in the snapshot.

</P>
<P>
Version numbers: Major 0, Minor 0

</P>
<P>
<B>The C128MEM module</B>

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>12 BYTE</TD>

<TD>MMU</TD>
<TD>dump of the 12 MMU registers</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM</TD>
<TD>128k RAM dump banks 0 and 1</TD>
</TR></TABLE>

<P>
<B>The C128ROM module</B>

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>KERNAL</TD>
<TD>8k dump of the kernal ROM</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BASIC</TD>
<TD>32k dump of the basic ROM</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>EDITOR</TD>
<TD>4k dump of the editor ROM</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>4k CHARGEN</TD>
<TD>dump of the chargen ROM</TD>
</TR></TABLE>



<H4><A NAME="SEC254" HREF="vice_toc.html#TOC254">9.2.2.17  VIC20 memory module</A></H4>

<P>
The VIC20 memory module actually consists of two modules.  The "VIC20MEM" module
is mandatory and contains the RAM dump.  The "VIC20ROM" module is optional
and contains a dump of the ROM images.

</P>
<P>
The size of the VIC20 memory modules differs with each different memory
configuration. The RAM configuration is saved in the snapshot, and
restored when the snapshot is loaded. The attached cartridges are
also restored upon load if they have been saved in the snapshot.

</P>
<P>
<B>The VIC20MEM module</B>

</P>
<P>
Version numbers: Major 1, Minor 0

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CONFIG</TD>
<TD>Configuration register.  Bits 0,1,2,3,5 reflect if the corresponding memory block is RAM (bit=1) or not (bit=0).</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM0</TD>
<TD>1k RAM dump $0000-$03ff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM1</TD>
<TD>4k RAM dump $1000-$1fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>COLORRAM</TD>
<TD>2k Color RAM, $9400-$9bff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK0</TD>
<TD>if CONFIG &#38; 1 then: 3k RAM dump $0400-$0fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK1</TD>
<TD>if CONFIG &#38; 2 then: 8k RAM dump $2000-$3fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK2</TD>
<TD>if CONFIG &#38; 4 then: 8k RAM dump $4000-$5fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK3</TD>
<TD>if CONFIG &#38; 8 then: 8k RAM dump $6000-$7fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK5</TD>
<TD>if CONFIG &#38; 32 then: 8k RAM dump $a000-$bfff</TD>
</TR></TABLE>

<P>
<B>The VIC20ROM module</B>

</P>
<P>
Version numbers: Major 1, Minor 1

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CONFIG</TD>
<TD>Bit 0: 1= ROM block $2*** enabled.  Bit 1: 1= ROM block $3*** enabled. Bit 2: 1= ROM block $4*** enabled.  Bit 3: 1= ROM block $5*** enabled. Bit 4: 1= ROM block $6*** enabled. Bit 5: 1= ROM block $7*** enabled. Bit 6: 1= ROM block $A*** enabled. Bit 7: 1= ROM block $B*** enabled.</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>KERNAL</TD>
<TD>8k KERNAL ROM image $e000-$ffff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BASIC</TD>
<TD>16k BASIC ROM image $c000-$dfff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>CHARGEN</TD>
<TD>4k CHARGEN ROM image</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK1A</TD>
<TD>4k ROM image $2*** (if CONFIG &#38; 1)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK1B</TD>
<TD>4k ROM image $3*** (if CONFIG &#38; 2)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK3A</TD>
<TD>4k ROM image $6*** (if CONFIG &#38; 16)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK3B</TD>
<TD>4k ROM image $7*** (if CONFIG &#38; 32)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK5A</TD>
<TD>4k ROM image $A*** (if CONFIG &#38; 64)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK5B</TD>
<TD>4k ROM image $B*** (if CONFIG &#38; 128)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK2A</TD>
<TD>4k ROM image $4*** (if CONFIG &#38; 4; added in V1.1)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK2B</TD>
<TD>4k ROM image $5*** (if CONFIG &#38; 8; added in V1.1)</TD>
</TR></TABLE>



<H4><A NAME="SEC255" HREF="vice_toc.html#TOC255">9.2.2.18  PET memory module</A></H4>

<P>
The PET memory module actually consists of three modules.  The "PETMEM" module
is mandatory and contains the RAM dump.  The "PETROM" module is optional
and contains a dump of the ROM images. The "PETDWW" module is also
optional and contains the image of the hires expansion board (if
enabled).

</P>
<P>
The size of the PET memory modules differs with each different memory
configuration.  The RAM configuration is saved in the snapshot, and
restored when the snapshot is loaded.

</P>
<P>
<B>The PETMEM module</B>

</P>
<P>
Version numbers: Major 1, Minor 3

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CONFIG</TD>
<TD>Configuration value. Bits 0-3: 0= 40 col PET without CRTC; 1= 40 col PET with CRTC; 2 = 80 col PET (with CRTC); 3= SuperPET; 4= 8096; 5= 8296. Bit 6: 1= RAM at $9***. Bit 7: 1= RAM at $A***.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>KEYBOARD</TD>
<TD>Keyboard type. 0= UK business; 1= Graphics; 2= German business</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>MEMSIZE</TD>
<TD>memory size of low 32k in k (possible values 4, 8, 16, 32)</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CONF8X96</TD>
<TD>Value of the 8x96 configuration register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SUPERPET</TD>
<TD>SuperPET config. Bit 0: 1= $9*** RAM enabled. Bit 1: 1= RAM write protected. Bit 2: 1= CTRL register write protected. Bit 3: 0= DIAG pin active. Bits 4-7: RAM block in use.</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM</TD>
<TD>4-32k RAM (not 8296, size depends on MEMSIZE)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>VRAM</TD>
<TD>2/4k RAM (not 8296, size depends on CONFIG)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>EXTRAM</TD>
<TD>64k expansion RAM (SuperPET and 8096 only)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM</TD>
<TD>128k RAM (8296 only)</TD>
</TR>
<TR><TD>--</TD>

<TD>--</TD>
<TD>The following item has been added in V1.1</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>POSITIONAL</TD>
<TD>bit 0=0 = symbolic keyboard mapping, bit 0=1 = positional mapping.</TD>
</TR>
<TR><TD>--</TD>

<TD>--</TD>
<TD>The following item has been added in V1.2</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>EOIBLANK</TD>
<TD>bit 0=0 = EOI does not blank screen, bit 0=1 = EOI blanks screen.</TD>
</TR>
<TR><TD>--</TD>

<TD>--</TD>
<TD>The following items have been added in V1.3</TD>
</TR>
<TR><TD>WORD</TD>

<TD>CPU_SWITCH</TD>
<TD>6502 / 6809 / PROG</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>VAL, PREVODD, WANTODD</TD>
<TD>6702 dongle state information</TD>
</TR>
<TR><TD>WORD[8]</TD>

<TD>SHIFT</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SuperPET config 2</TD>
<TD>Extra bits due to the Super-OS-9 MMU. Bit 5: FIRQ disabled. Bit 6:</TD>
expansion memory in OS-9 flat mode.

</TR></TABLE>

<P>
The POSITIONAL item has been added in PETMEM snapshot version 1.1. It is
ignored by earlier restore routines (V1.0) and the V1.1 restore routines
do not change the current setting when reading a V1.0 snapshot.

</P>
<P>
In V1.2 the new EOIBLANK variable has been added. This implements
the "blank screen on EOI" feature that was previously linked to a wrong
resource.

</P>
<P>
In V1.3 the state for SuperPET has been added.

</P>
<P>
<B>The PETROM module</B>

</P>
<P>
Version numbers: Major 1, Minor 1

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CONFIG</TD>
<TD>Bit 0: 1= $9*** ROM included. Bit 1: 1= $A*** ROM included. Bit 2: 1= $B*** ROM included. Bit 3: 1= $e900-$efff ROM included. Bit 4: 1= SuperPET ROMs included.</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>KERNAL</TD>
<TD>4k KERNAL ROM image $f000-$ffff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>EDITOR</TD>
<TD>2k EDITOR ROM image $e000-$e7ff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>CHARGEN</TD>
<TD>2k CHARGEN ROM image</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROM9</TD>
<TD>4k $9*** ROM image (if CONFIG &#38; 1)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROMA</TD>
<TD>4k $A*** ROM image (if CONFIG &#38; 2)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROMB</TD>
<TD>4k $B*** ROM image (if CONFIG &#38; 4)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROMC</TD>
<TD>4k $C*** ROM image</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROMD</TD>
<TD>4k $D*** ROM image</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROME9</TD>
<TD>7 blocks $e900-$efff ROM image (if CONFIG &#38; 8)</TD>
</TR>
<TR><TD>--</TD>

<TD>--</TD>
<TD>The following items have been added in V1.1</TD>
</TR>
<TR><TD>ROM6809</TD>

<TD>ROM6809</TD>
<TD>24k $A000-$FFFF ROM   (if CONFIG &#38; 16)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>CHARGEN(2)</TD>
<TD>upper half of CHARGEN (if CONFIG &#38; 16)</TD>
</TR></TABLE>

<P>
<B>The PETDWW module</B>

</P>
<P>
For storing the state of the DWW hires expansion board, there is a
PETDWWPIA module, and a DWWMEM module.

</P>
<P>
The former has the same format as the PIA1.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>WORD</TD>

<TD>SIZE</TD>
<TD>The size of the memory dump that follows, or 0 if DWW disabled.</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>MEM</TD>
<TD>The memory in the DWW card, SIZE bytes.</TD>
</TR></TABLE>



<H4><A NAME="SEC256" HREF="vice_toc.html#TOC256">9.2.2.19  CBM-II memory module</A></H4>

<P>
The CBM-II memory module actually consists of two modules.  The
"CBM2MEM" module is mandatory and contains the RAM dump.  The "CBM2ROM"
module is optional and contains a dump of the ROM images.

</P>
<P>
The size of the CBM-II memory modules differs with each different memory
configuration.  The RAM configuration is saved in the snapshot, and
restored when the snapshot is loaded.

</P>
<P>
Version numbers: Major 1, Minor 0

</P>
<P>
<B>The CBM2MEM module</B>

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>MEMSIZE</TD>
<TD>Memory size in 128k blocks (1=128k, 2=256k, 4=512k, 8=1024k)</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CONFIG</TD>
<TD>Bit 0 = $f0800-$f0fff RAM, Bit 1 = $f1000-$f1fff RAM, Bit 2 = $f2000-$f3fff RAM, Bit 3 = $f4000-$f5fff RAM, Bit 4 = $f6000-$f7fff RAM, Bit 5 = $fc000-$fcfff RAM, Bit 6 = is a C500</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>HWCONFIG</TD>
<TD>Bit 0/1: model line configuration</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>EXECBANK</TD>
<TD>CPUs execution bank register</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>INDBANK</TD>
<TD>CPUs indirection bank register</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>SYSRAM</TD>
<TD>2k system RAM $f0000-$f07ff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>VIDEO</TD>
<TD>2k video RAM $fd000-$fd7ff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM</TD>
<TD>RAM dump, size according to MEMSIZE</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM08</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 1 : 2k RAM $f0800-$f0fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM1</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 2 : 4k RAM $f1000-$f1fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM2</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 4 : 8k RAM $f2000-$f3fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM4</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 8 : 8k RAM $f4000-$f5fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM6</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 16 : 8k RAM $f6000-$f7fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAMC</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 32 : 4k RAM $fc000-$fcfff</TD>
</TR></TABLE>

<P>
The RAM* arrays are only saved if the RAM itself is less than 1M.
If the memory size is 1M then those areas are taken from the
bank 15 area of the normal RAM.

</P>
<P>
The memory array starts at $10000 if the memory size is less than 512k,
or at $00000 if 512k or more. In case of a C510, then the memory array
also always starts at $00000.

</P>
<P>
<B>The CBM2ROM module</B>

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CONFIG</TD>
<TD>Bit 1: 1= $1*** ROM image included. Bit 2: 1= $2000-$3fff ROM image included. Bit 3: 1= $4000-$5fff ROM image included. Bit 4: 1= $6000-$7fff ROM image included. Bit 5: 1= chargen ROM is VIC-II chargen, 0= CRTC chargen.</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>KERNAL</TD>
<TD>8 KERNAL ROM image ($e000-$efff)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BASIC</TD>
<TD>BASIC ROM image ($8000-$bfff)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>CHARGEN</TD>
<TD>4k CHARGEN ROM image</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROM1</TD>
<TD>4k cartridge ROM image for $1*** (if CONFIG &#38; 2)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROM2</TD>
<TD>8k cartridge ROM image for $2000-$3fff (if CONFIG &#38; 4)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROM4</TD>
<TD>8k cartridge ROM image for $4000-$5fff (if CONFIG &#38; 8)</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>ROM6</TD>
<TD>8k cartridge ROM image for $6000-$7fff (if CONFIG &#38; 16)</TD>
</TR></TABLE>



<H4><A NAME="SEC257" HREF="vice_toc.html#TOC257">9.2.2.20  C500 data module</A></H4>

<P>
The C500 data module contains simple state information not already saved
in the other modules.

</P>
<P>
Version numbers: Major 0, Minor 0

</P>
<P>
<B>The C500DATA module</B>

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>IRQCLK</TD>
<TD>CPU clock ticks till next 50Hz IRQ</TD>
</TR></TABLE>

<P><HR><P>
Go to the <A HREF="vice_1.html">first</A>, <A HREF="vice_8.html">previous</A>, <A HREF="vice_10.html">next</A>, <A HREF="vice_22.html">last</A> section, <A HREF="vice_toc.html">table of contents</A>.
</BODY>
</HTML>
